/* Plugin generated by AMXX-Studio */

#include <amxmodx>
#include <amxmisc>
#include <engine>
#include <fakemeta>
#include <fakemeta_util>
#include <cstrike>
#include <hamsandwich>
#include <xs>
#include <fun>
#include <zombie_stage_const>
#include <zombie_stage>
#include <zombie_scenario_utils>

#define PLUGIN "[FUN AllStar] Zombie Class : Rusty Wings"
#define VERSION "1.0"
#define AUTHOR 	"Mellowzy"

#define TASK_SPEEDRUN 					109210
#define TASK_AURA 					12003
#define TASK_COOLDOWN 					202020
#define TASK_DOWNHILL 					20210201

#define pev_nade_type      				pev_flTimeStepSound
#define NADE_TYPE_JUMPING    				26517
#define RADIUS        					300.0
#define MAXPLAYERS       				32

#define DAMAGE_MULTI 					5.0

new const g_iTaskDownhillEnd				= 71871379;
new const g_iTaskDownhillStart				= 71891738;
new const g_iTaskFlyEnd					= 23783758;
new const g_iTaskFlyIdle				= 27869755;
new const g_iTaskFlySound				= 27611333;
new const g_iTaskFlyStart				= 68468633;

new const Float:g_flDurationFly				= 10.0; 

new const Float:g_flDurationDownhill			= 2.0;
new const Float:g_flDownhillSpeedY			= -450.0;
new const g_iDownhillSpeed				= 1050; 
new const g_iDownhillEndSpeed				= 200; 


const UNIT_SECOND 					= (1<<12)


new const flyzombi_f_voices[][] = 
{
	"zombie_plague/rustywing_downhill_start.wav", //0
	"zombie_plague/rustywing_fly_idle.wav", //1
	
	"zombie_plague/rustywing_downhill_start.wav",  //2
	"zombie_plague/rustywing_fly_idle.wav", //3
	
	"zombie_plague/rustywing_fly_start.wav", //4
	"zombie_plague/rustywing_pressure.wav", //5
}

new bool:g_bIsRustyWing[33]
new bool:g_bInFly[33], bool:g_bInDownhill[33], gIsFly[33]
new bool:g_bSkillReady[33];

new const szPainSound[] = "zombie_plague/rustywing_hurt1.wav"
new const szPainSound_2[] = "zombie_plague/rustywing_hurt2.wav"
new const szDeathSound[] = "zombie_plague/rustywing_death2.wav"

// Rusty Wing
new const zombieclass1_name[] = "Rusty Wing"
new const zombieclass1_model[] = "rusty_wing"
const zombieclass1_health = 500
const Float:zombieclass1_speed = 220.0
const Float:zombieclass1_gravity = 0.8
const Float:zombieclass1_knockback = 1.1
const iShowOnStage = STAGE_3;
const iHideOnStage = DO_NOT_HIDE;
const iMaxCount = 1;
new g_iClassId;

new cvar_cooldown , cvar_dmg2stop
new Float:g_fTakenDmg[33];		// dmg taken when flying

public plugin_init() {
	register_plugin(PLUGIN, VERSION, AUTHOR)

	cvar_cooldown = register_cvar("zs_rustywing_cooldown", "5.0")
	cvar_dmg2stop = register_cvar("zs_rustywing_dmg2stop", "30.0")

	RegisterHam(Ham_TakeDamage,"player","Ham_TakeDamage_Post",1);
	
}

public plugin_precache()
{
	g_iClassId = zs_class_zombie_register(zombieclass1_name, zombieclass1_model, zombieclass1_health, zombieclass1_speed, zombieclass1_gravity,zombieclass1_knockback, iShowOnStage,iHideOnStage, iMaxCount)
	zs_class_zombie_register_sound(g_iClassId, szDeathSound , szPainSound, szPainSound_2);
	new i;
	for(i = 0; i <sizeof(flyzombi_f_voices); i++)
		precache_sound(flyzombi_f_voices[i])
}

public zs_fw_core_turn_to_zombie_post(id)
{
	remove_task(id+TASK_COOLDOWN)
	remove_task(id+TASK_DOWNHILL)

	g_bSkillReady[id] = false;
	g_bInDownhill[id] = false;
	g_bInFly[id] = false;
	gIsFly[id] = 0
	g_fTakenDmg[id] = 0.0;

	if(zs_core_get_player_zombie_class(id) == g_iClassId && is_user_alive(id))
	{
		g_bIsRustyWing[id] = true;
		set_task(get_pcvar_float(cvar_cooldown), "reset_cooldown", id+TASK_COOLDOWN)
	}

}

public zs_fw_core_zombie_killed_post(id)
{
	g_bIsRustyWing[id] = false;
}


public client_connect(id){
	remove_stuff(id)
	ResetVariables(id)
}
public client_disconnected(id){
	remove_stuff(id)
	ResetVariables(id)
}

public remove_stuff(id)
{
	g_bIsRustyWing[id] = false;
	g_bSkillReady[id] = false;

	remove_task(id+TASK_COOLDOWN)
	remove_task(id+TASK_DOWNHILL)
}

// Drag player if hit
public Ham_TakeDamage_Post(victim, inflictor, attacker, Float:damage, damage_type)
{	
	if(!g_bIsRustyWing[victim])
		return HAM_IGNORED

	if(g_bInFly[victim] || g_bInDownhill[victim])
	{
		g_fTakenDmg[victim] += damage;
		if(g_fTakenDmg[victim] >= get_pcvar_float(cvar_dmg2stop))
		{
			g_fTakenDmg[victim] == 0.0;
			g_bInFly[victim] = false;
			g_bInDownhill[victim] = false;
			gIsFly[victim] = 0
			remove_task(g_iTaskFlyStart + victim);
			remove_task(g_iTaskFlyIdle + victim);
			remove_task(g_iTaskFlyEnd + victim);
			remove_task(g_iTaskFlySound + victim);
			remove_task(g_iTaskDownhillEnd + victim);

			if(!task_exists(TASK_COOLDOWN + victim))
				set_task(get_pcvar_float(cvar_cooldown), "reset_cooldown", victim+TASK_COOLDOWN)
		}

	}

	return HAM_IGNORED
}

public client_PreThink(id)
{
	if(!g_bIsRustyWing[id])
		return

	if(g_bSkillReady[id] && !g_bInFly[id] && !g_bInDownhill[id] && (pev(id, pev_flags) & FL_ONGROUND) && Get_Random_Visible_Alive_PlayerId_Within_Range(id, 2000) > 0)
	{
		abilityFly(id);
		gIsFly[id] = 2
		return;
	} 

	// Flying , and has target within range
	if(g_bInFly[id] && !g_bInDownhill[id] && Get_Random_Visible_Alive_PlayerId_Within_Range(id, 700) > 0)
	{
		abilityDownhill(id);
		gIsFly[id] = 3
		return;
	}

	if(g_bInFly[id]) {
	
		new Float:vecVelocity[3];
		velocity_by_aim(id, 400, vecVelocity);
		vecVelocity[2] = 0.0;
		set_pev(id, pev_velocity, vecVelocity);
	
	} else if(g_bInDownhill[id]) {
		static Float:vecVelocity[3];
		if(pev(id, pev_flags) & FL_ONGROUND){
			g_bInDownhill[id] = false;
			velocity_by_aim(id, 0, vecVelocity);
			set_pev(id, pev_velocity, vecVelocity);
		} else { 
			velocity_by_aim(id, g_iDownhillSpeed, vecVelocity);
			vecVelocity[2] = g_flDownhillSpeedY;
			set_pev(id, pev_velocity, vecVelocity);
		}
	}
}

public abilityFly(iPlayer) {

	UTIL_PlayAnimation(iPlayer, 0.3, 1.0, 143);
	set_task(0.3, "task_FlyStart", g_iTaskFlyStart + iPlayer);
	g_bSkillReady[iPlayer] = false;
}


public abilityDownhill(iPlayer) {
	
	emit_sound(iPlayer, CHAN_STREAM, flyzombi_f_voices[2], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
	
	g_bInFly[iPlayer] = false;
	g_bInDownhill[iPlayer] = true;
	g_bSkillReady[iPlayer] = false;
	
	UTIL_PlayAnimation(iPlayer, 0.3, 1.0, 147);
	
	set_task(0.3, "task_DownhillStart", g_iTaskDownhillStart + iPlayer);
	if(task_exists(g_iTaskFlyStart + iPlayer)) 	remove_task(g_iTaskFlyStart + iPlayer);
	if(task_exists(g_iTaskFlyIdle + iPlayer)) 	remove_task(g_iTaskFlyIdle + iPlayer);
	if(task_exists(g_iTaskFlyEnd + iPlayer)) 	remove_task(g_iTaskFlyEnd + iPlayer);
	if(task_exists(g_iTaskFlySound + iPlayer)) 	remove_task(g_iTaskFlySound + iPlayer);

}


public task_DownhillStart(iPlayer) {

	iPlayer -= g_iTaskDownhillStart;
	if(is_user_alive(iPlayer)) {
		UTIL_PlayAnimation(iPlayer, g_flDurationDownhill, 0.2, 148);
		set_task(g_flDurationDownhill, "task_DownhillEnd", g_iTaskDownhillEnd + iPlayer);
	}
	
}

public task_DownhillEnd(iPlayer) {

	iPlayer -= g_iTaskDownhillEnd;
	g_bInDownhill[iPlayer] = false;
	gIsFly[iPlayer] = 0
	
	if(is_user_alive(iPlayer)) {
	
		UTIL_PlayAnimation(iPlayer, 0.2, 1.0, 149);
	
		new Float:vecVelocity[3]; velocity_by_aim(iPlayer, g_iDownhillEndSpeed, vecVelocity);
		vecVelocity[2] = -20.0; set_pev(iPlayer, pev_velocity, vecVelocity);
	}
	
	if(!task_exists(TASK_COOLDOWN + iPlayer))
	{
		set_task(get_pcvar_float(cvar_cooldown), "reset_cooldown", iPlayer+TASK_COOLDOWN)
	}
}

/*
public Player_Touch(ent, id)
{
	// When it is flying down & touch the ground.
	if(g_bIsRustyWing[id] && g_bInDownhill[id] && is_user_alive(id))
	{
		g_bInDownhill[id] = false
		gIsFly[id] = 0
		UTIL_PlayAnimation(id, 0.2, 1.0, 149);
		new Float:vecVelocity[3]; velocity_by_aim(id, 0, vecVelocity);
		set_pev(id, pev_velocity, vecVelocity);
		
		/*
		new i
		static Float:vel[3]
		pev(id, pev_velocity, vel)
		vel[2] += 20.0
		for(i = 0; i < get_maxplayers(); i++)
		{
			if(!is_user_alive(i)) continue
			if(id == i) continue
			if(entity_range(id, i) > 120.0) continue
			if(pev(i, pev_takedamage) == DAMAGE_NO) continue
			
			ExecuteHamB(Ham_TakeDamage, i, id, id, DAMAGE_MULTI, DMG_SLASH)
			set_pev(i, pev_velocity, vel)
		}
		

		
		if(!task_exists(TASK_COOLDOWN + id))
		{
			set_task(get_pcvar_float(cvar_cooldown), "reset_cooldown", id+TASK_COOLDOWN)
		}
		
	}
}
*/

public task_FlyStart(iPlayer) {

	iPlayer -= g_iTaskFlyStart;
	if(is_user_alive(iPlayer)) {
	
		new Float:vecVelocity[3]; pev(iPlayer, pev_velocity, vecVelocity);
		vecVelocity[2] = 1000.0; set_pev(iPlayer, pev_velocity, vecVelocity);
		
		UTIL_PlayAnimation(iPlayer, 0.6, 1.0, 144);
		
		set_task(0.7, "task_FlyIdle", g_iTaskFlyIdle + iPlayer);
		emit_sound(iPlayer, CHAN_STREAM, flyzombi_f_voices[4], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);
	}

}
public task_FlyIdle(iPlayer) {

	iPlayer -= g_iTaskFlyIdle;
	g_bInFly[iPlayer] = true;
	
	if(is_user_alive(iPlayer)) {
	
		UTIL_PlayAnimation(iPlayer, 10.0, 2.5, 146);
		set_task(g_flDurationFly, "task_FlyEnd", g_iTaskFlyEnd + iPlayer);
		set_task(0.7, "task_FlySound", g_iTaskFlySound + iPlayer, _, _, "a", floatround(g_flDurationFly / 0.7));
	}

}

public task_FlySound(iPlayer) {

	iPlayer -= g_iTaskFlySound;
	emit_sound(iPlayer, CHAN_STREAM, flyzombi_f_voices[3], VOL_NORM, ATTN_NORM, 0, PITCH_NORM);

}
public task_FlyEnd(iPlayer) {

	iPlayer -= g_iTaskFlyEnd;
	g_bInFly[iPlayer] = false;
	gIsFly[iPlayer] = 0
	if(is_user_alive(iPlayer)) UTIL_PlayAnimation(iPlayer, 0.3, 1.0, 145);

	set_task(get_pcvar_float(cvar_cooldown), "reset_cooldown", iPlayer+TASK_COOLDOWN)

}

public reset_cooldown(taskid)
{
	new id = taskid - TASK_COOLDOWN;
	g_bSkillReady[id] = true;
}
		
stock Set_WeaponAnim(id, anim)
{
	set_pev(id, pev_weaponanim, anim)
	
	message_begin(MSG_ONE_UNRELIABLE, SVC_WEAPONANIM, {0, 0, 0}, id)
	write_byte(anim)
	write_byte(pev(id, pev_body))
	message_end()
}

////////////////////////////////////////////////////////////////
stock can_damage(id1, id2)
{
	if(id1 <= 0 || id1 >= 33 || id2 <= 0 || id2 >= 33)
		return 1
		
	// Check team
	return(get_pdata_int(id1, 114) != get_pdata_int(id2, 114))
}
stock Get_SpeedVector(const Float:origin1[3],const Float:origin2[3],Float:speed, Float:new_velocity[3])
{
	new_velocity[0] = origin2[0] - origin1[0]
	new_velocity[1] = origin2[1] - origin1[1]
	new_velocity[2] = origin2[2] - origin1[2]
	new Float:num = floatsqroot(speed*speed / (new_velocity[0]*new_velocity[0] + new_velocity[1]*new_velocity[1] + new_velocity[2]*new_velocity[2]))
	new_velocity[0] *= num
	new_velocity[1] *= num
	new_velocity[2] *= num
	
	return 1;
}
stock set_user_takedamage(index, damage)
{
	if(!is_user_alive(index))
		return

	new vec[3]
	FVecIVec(get_target_origin_f(index), vec)

	message_begin(MSG_ONE, get_user_msgid("Damage"), _, index)
	write_byte(0)
	write_byte(damage)
	write_long(DMG_CRUSH)
	write_coord(vec[0]) 
	write_coord(vec[1])
	write_coord(vec[2])
	message_end()

	if(pev(index, pev_health) - 20.0 <= 0)
		ExecuteHamB(Ham_Killed, index, index, 1)
	else ExecuteHamB(Ham_TakeDamage, index, 0, index, float(damage), DMG_BLAST)
}
stock Float:get_target_origin_f(index)
{
	new Float:orig[3]
	pev(index, pev_origin, orig)

	if(index > get_maxplayers())
	{
		new Float:mins[3], Float:maxs[3]
		pev(index, pev_mins, mins)
		pev(index, pev_maxs, maxs)
		
		if(!mins[2]) orig[2] += maxs[2] / 2
	}
	return orig
}

stock get_speed_vector(const Float:origin1[3],const Float:origin2[3],Float:speed, Float:new_velocity[3])
{
	new_velocity[0] = origin2[0] - origin1[0]
	new_velocity[1] = origin2[1] - origin1[1]
	new_velocity[2] = origin2[2] - origin1[2]
	new Float:num = floatsqroot(speed*speed / (new_velocity[0]*new_velocity[0] + new_velocity[1]*new_velocity[1] + new_velocity[2]*new_velocity[2]))
	new_velocity[0] *= num
	new_velocity[1] *= num
	new_velocity[2] *= num
       
	return 1;
}
stock shake_screen(id)
{
	if(!id) 
	{
		message_begin(MSG_BROADCAST, get_user_msgid("ScreenShake"))
		write_short(8<<12)
		write_short(5<<12)
		write_short(4<<12)
		message_end()
	} 
	else 
	{
		if(!is_user_connected(id) || !is_user_alive(id))
			return
			
		message_begin(MSG_BROADCAST, get_user_msgid("ScreenShake"), _, id)
		write_short(8<<12)
		write_short(5<<12)
		write_short(4<<12)
		message_end()
	}
}
stock UTIL_ScreenFade(iPlayer, iDuration, iHold, iRed, iGreen, iBlue, iAlpha, iFlag) {

	if(!is_user_connected(iPlayer)) return PLUGIN_HANDLED;
	
	message_begin(MSG_ONE, get_user_msgid("ScreenFade"), _, iPlayer);
	write_short(1<<iDuration);
	write_short(1<<iHold);
	write_short(1<<iFlag);
	write_byte(iRed);
	write_byte(iGreen);
	write_byte(iBlue);
	write_byte(iAlpha);
	message_end();
	
	return PLUGIN_HANDLED;

}

stock UTIL_PlayAnimation(iPlayer, Float:flTime, Float:flFramerate, iSequence) {

	set_pev(iPlayer, pev_animtime, flTime);
	set_pev(iPlayer, pev_framerate, flFramerate);
	set_pev(iPlayer, pev_sequence, iSequence);
	set_pev(iPlayer, pev_gaitsequence, iSequence);

}
stock Stock_SetPlayerAnim(id, const AnimName[], Float:rate=1.0)
{
	static AnimNum, Float:FrameRate, Float:GroundSpeed, bool:Loops, Anim2[64]
	if(!(pev(id, pev_flags) & FL_DUCKING)) format(Anim2, 63, "ref_%s", AnimName)
	else format(Anim2, 63, "crouch_%s", AnimName)

	if ((AnimNum=lookup_sequence(id,Anim2,FrameRate,Loops,GroundSpeed))==-1) AnimNum=0
	
	if (!Loops || (Loops && pev(id,pev_sequence)!=AnimNum))
	{
		set_pev(id, pev_gaitsequence, AnimNum)
		set_pev(id, pev_sequence, AnimNum)
		set_pev(id, pev_frame, 0.0)
		set_pev(id, pev_animtime, get_gametime())
	}
	set_pev(id, pev_framerate, rate)

	set_pdata_int(id, 40, Loops, 4)
	set_pdata_int(id, 39, 0, 4)

	set_pdata_float(id, 36, FrameRate, 4)
	set_pdata_float(id, 37, GroundSpeed, 4)
	set_pdata_float(id, 38, get_gametime(), 4)

	set_pdata_int(id, 73, 28, 5)
	set_pdata_int(id, 74, 28, 5)
	set_pdata_float(id, 220, get_gametime(), 5)
}

ResetVariables(iPlayer) {

	g_bSkillReady[iPlayer] = false;
	g_bInFly[iPlayer] = false;
	g_bInDownhill[iPlayer] = false;
	
	if(is_user_alive(iPlayer)) set_user_rendering(iPlayer);
	remove_task(TASK_COOLDOWN + iPlayer)
}
/* AMXX-Studio Notes - DO NOT MODIFY BELOW HERE
*{\\ rtf1\\ ansi\\ deff0{\\ fonttbl{\\ f0\\ fnil Tahoma;}}\n\\ viewkind4\\ uc1\\ pard\\ lang1033\\ f0\\ fs16 \n\\ par }
*/
